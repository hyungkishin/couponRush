### 문제점

- 아래 테스트 코드를 실행시 문제가 발생한다.
    - 아래 서비스 로직에서 100 개가 넘을 경우, 종료된다.

```java
    public void apply(Long userId){
        long count=couponRepository.count();

        if(count>100){
        return;
        }

        couponRepository.save(new Coupon(userId));
        }
```

### 테스트 코드

```java
    @Test
public void 여러명응모()throws InterruptedException{
        int threadCount=110;  // 실제와 유사한 환경을 모방하도록 스레드 수 조정

        // multiThread (병렬 작업을 도와주는 Java api)
        ExecutorService executorService=Executors.newFixedThreadPool(10); // 연결 풀 크기에 맞춘 스레드 풀 크기

        // 모든 요청이 끝날때 까지 기다림 ( 다른 스레드에서 수행하는 작업을 기다려주도록 도와주는 class )
        CountDownLatch latch=new CountDownLatch(threadCount);

        for(int i=0;i<threadCount; i++){
        long userId=i;
        executorService.submit(()->{
        try{
        applyService.apply(userId);
        }finally{
        latch.countDown();
        }
        });
        }

        latch.await();  // 모든 스레드의 작업 완료를 기다림

        executorService.shutdown();  // 스레드 풀 종료

        long count=couponRepository.count();  // 모든 적용이 완료된 후에 쿠폰 수 검사

        assertThat(count).isEqualTo(100);  // 비즈니스 로직에서 제한했던 쿠폰 응모수 100개와 일치하는지
        }
```

### 문제점

- 레이즈 컨디션 때문에 테스트가 실패한다.

> 레이즈 컨디션이란 두개이상의 쓰레드가 공유 데이터에 엑세스를 하고 동시에 작업을 하려고 할때 발생하는 문제이다.

### 예시 (예상 시나리오)

| Thread-1                    | Coupon count | Thread-2                    |
|-----------------------------|--------------|-----------------------------|
| select count(*) from coupon | 99           |                             |
| create coupon               | 100          |                             |
|                             | 100          | select count(*) from coupon |
|                             | 100          | faild create coupon         |

> 우리는 Thread 1 이 생성된 쿠폰의 갯수를 가져가고 아직 100개가 아니므로 쿠폰을 생성하고 Thread 2 가 <br/>
> 생성된 쿠폰의 갯수를 가져갔을떄 이미생성된 쿠폰의 갯수가 100개 이므로 쿠폰을 생성하지 않는것을 예상했다. <br/>

### 현실

| Thread-1                    | Coupon count | Thread-2                    |
|-----------------------------|--------------|-----------------------------|
| select count(*) from coupon | 99           |                             |
|                             | 99           | select count(*) from coupon |
| create coupon               | 100          |                             |
|                             | 101          | create coupon               |
> 실제로는 Thread 1 이 생성된 쿠폰의 갯수를 가져가고 Thread 1이 쿠폰을 생성하기 전에 Thread 2 가 생성된 쿠폰의 갯수를 가져가게 된다. <br/>
> 그래서 Thread 2 가 가져가는 쿠폰의 갯수는 99 개 일것이고 결과적으로 100 개가 넘어가는 쿠폰의 갯수 때문에 테스트가 실패한 것이다.

### 결론
- 이렇게 두개 이상의 쓰레드가 공유자원에 엑세스를 하고 작업을 하려고할때 발생되는 문제점을 레이스 컨디션 이라고 한다.
